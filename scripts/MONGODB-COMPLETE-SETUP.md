# MongoDB – Complete setup (everything stored, safe & secure)

This guide tells you **exactly** what to create in MongoDB so the banking app stores **all** data in the database (logins, customers, accounts, transactions, notifications) and follows **real-world security** practices.

---

## What gets stored where

| Database | Collection | What is stored |
|----------|------------|----------------|
| **banking_accounts** | **sequences** | Counters for generating IDs (1, 2, 3…) – required for app |
| **banking_accounts** | **bank_users** | **Login credentials** – username + **password hash only** (never plain text), role (ADMIN/CUSTOMER), link to customer |
| **banking_accounts** | **customers** | Customer details: name, email, phone |
| **banking_accounts** | **accounts** | Account details: account number, balance, type, status, currency, link to customer |
| **banking_transactions** | **transactions** | Every transfer, deposit, withdrawal – type, amount, from/to, status, time |
| **banking_notifications** | **notifications** | Notifications per account |
| **banking_notifications** | **audit_logs** | Audit trail (who did what, when) |

**Security (real-world):**
- **Passwords:** Only **BCrypt hashes** are stored in `bank_users.passwordHash`. Plain passwords are never saved.
- **Unique constraints:** Username, email, and account number are unique (indexes below).
- **Application:** Uses JWT for sessions and role-based access (customer vs admin).

---

## Step 1: Create the three databases

In Compass (or mongosh), create these databases by creating a collection in each:

1. **banking_accounts**
2. **banking_transactions**
3. **banking_notifications**

(You create a database by adding at least one collection to it.)

---

## Step 2: Database `banking_accounts`

### 2.1 Collection: `sequences` (required)

The app uses this to generate numeric IDs. Create **3 documents**:

**Document 1:**
```json
{
  "_id": "customers",
  "seq": 0
}
```

**Document 2:**
```json
{
  "_id": "accounts",
  "seq": 0
}
```

**Document 3:**
```json
{
  "_id": "bank_users",
  "seq": 0
}
```

- **Field types:** `_id` = string, `seq` = number (integer).

---

### 2.2 Collection: `bank_users` (logins – required to sign in)

Stores **all login users** (admin and customers). Passwords are **only stored as BCrypt hash**, never plain text.

**Option A – Let the app create admin (recommended):**  
Create an **empty** collection `bank_users`. Start **account-service** once; it will add the default admin (username: `admin`, password: `admin123`) with a correct hash.

**Option B – Create admin yourself:**  
Add **1 document** (use Compass “Add data” → “Insert document”):

```json
{
  "_id": NumberLong(1),
  "username": "admin",
  "passwordHash": "$2a$10$8K1p/a0dL1LXMIgoEDFrwOfMQbL4sGxYXo/bvFhVvPm6VHqGvJQyO",
  "customerId": null,
  "role": "ADMIN"
}
```

- `_id`: number (Int64/long), e.g. 1  
- `username`: string, must be **unique**  
- `passwordHash`: string (BCrypt hash; the value above is for password **admin123**)  
- `customerId`: null for admin; for customer users this is the `_id` from `customers`  
- `role`: string, either `"ADMIN"` or `"CUSTOMER"`

Then update `sequences`: find document `_id: "bank_users"` and set `seq: 1`.

**Index for safety (unique username):**  
In Compass: open `bank_users` → Indexes → Create Index.  
Index key: `{ "username": 1 }`, option: **Unique: true**.  
So no two users can have the same username.

---

### 2.3 Collection: `customers`

Stores **all customers**. You can leave it **empty**; the app will create documents when an admin adds customers.

**Schema (each document):**

| Field   | Type   | Required | Notes                    |
|---------|--------|----------|--------------------------|
| `_id`   | Long   | Yes      | Generated by app (sequence) |
| `name`  | String | Yes      | Full name                |
| `email` | String | Yes      | Must be **unique**       |
| `phone` | String | Yes      |                          |

**Index for safety (unique email):**  
Create index: `{ "email": 1 }`, **Unique: true**.

---

### 2.4 Collection: `accounts`

Stores **all accounts** (balance, type, status, link to customer). Leave **empty**; the app will create documents when an admin creates accounts or when you use the app.

**Schema (each document):**

| Field            | Type    | Required | Notes                         |
|------------------|---------|----------|-------------------------------|
| `_id`            | Long    | Yes      | Generated by app (sequence)   |
| `accountNumber`  | String  | Yes      | Must be **unique** (e.g. ACC…) |
| `type`           | String  | Yes      | `"SAVINGS"` or `"CURRENT"`    |
| `balance`        | Number  | Yes      | Decimal, e.g. 0 or 100.50     |
| `status`         | String  | Yes      | `"ACTIVE"`, `"BLOCKED"`, `"CLOSED"` |
| `currency`       | String  | Yes      | e.g. `"USD"`                  |
| `customerId`     | Long    | Yes      | Same as `_id` in `customers`  |
| `createdAt`      | Date    | Yes      | When account was created      |

**Index for safety (unique account number):**  
Create index: `{ "accountNumber": 1 }`, **Unique: true**.

**Index for queries (accounts by customer):**  
Create index: `{ "customerId": 1 }` (unique: false).

---

## Step 3: Database `banking_transactions`

### 3.1 Collection: `transactions`

Stores **every** transfer, deposit, and withdrawal. Leave **empty**; the app will add documents when users perform transactions.

**Schema (each document):**

| Field               | Type   | Notes                              |
|---------------------|--------|------------------------------------|
| `_id`               | String | Auto-generated by MongoDB (ObjectId) |
| `type`              | String | `"TRANSFER"`, `"DEPOSIT"`, `"WITHDRAWAL"` |
| `amount`            | Number | Decimal                             |
| `fromAccountNumber` | String | Null for deposit                    |
| `toAccountNumber`   | String | Null for withdrawal                 |
| `status`            | String | `"PENDING"`, `"COMPLETED"`, `"FAILED"` |
| `reference`         | String | Optional note                       |
| `createdAt`         | Date   | Time of transaction                 |

**Index for queries (history by account):**  
Create index: `{ "fromAccountNumber": 1, "createdAt": -1 }` and/or `{ "toAccountNumber": 1, "createdAt": -1 }` (or a compound index) so history by account is fast.

---

## Step 4: Database `banking_notifications`

### 4.1 Collection: `notifications`

Stores notifications per account. Leave **empty**; the app will add documents when needed.

**Schema:** `_id` (String), `accountNumber`, `type`, `message`, `readFlag` (boolean), `createdAt` (Date).

### 4.2 Collection: `audit_logs`

Stores audit trail (who did what, when). Leave **empty**; the app will add documents when needed.

**Schema:** `_id` (String), `eventType`, `entityType`, `entityId`, `accountNumber`, `details`, `createdAt` (Date).

---

## Step 5: Indexes summary (for safety and performance)

Run these in the **Mongosh** tab in Compass (switch to database with `use banking_accounts` etc.):

**banking_accounts:**
```javascript
use banking_accounts

// Unique: no duplicate usernames
db.bank_users.createIndex({ "username": 1 }, { unique: true })

// Unique: no duplicate emails
db.customers.createIndex({ "email": 1 }, { unique: true })

// Unique: no duplicate account numbers
db.accounts.createIndex({ "accountNumber": 1 }, { unique: true })

// Fast lookup of accounts by customer
db.accounts.createIndex({ "customerId": 1 })
```

**banking_transactions:**
```javascript
use banking_transactions

// Fast history by account
db.transactions.createIndex({ "fromAccountNumber": 1, "createdAt": -1 })
db.transactions.createIndex({ "toAccountNumber": 1, "createdAt": -1 })
```

---

## Checklist – minimum to create so everything is stored

| Step | Where | What to do |
|------|--------|------------|
| 1 | banking_accounts | Create collection **sequences** with 3 documents: `_id` = "customers", "accounts", "bank_users"; each `seq: 0`. |
| 2 | banking_accounts | Create collection **bank_users**. Either leave empty and start app once (app creates admin), or add 1 admin document (see 2.2). |
| 3 | banking_accounts | Create index on `bank_users.username` (unique). |
| 4 | banking_accounts | Create collection **customers** (empty). Create unique index on `email`. |
| 5 | banking_accounts | Create collection **accounts** (empty). Create unique index on `accountNumber`; index on `customerId`. |
| 6 | banking_transactions | Create collection **transactions** (empty). Create indexes for from/to + createdAt. |
| 7 | banking_notifications | Create collections **notifications** and **audit_logs** (empty). |

After this, **all** data the app uses (logins, customers, accounts, transactions, notifications) will be stored in MongoDB. The app will create and update documents as users sign in, activate, create customers/accounts, and perform transactions.

---

## Security summary (real-world)

- **Passwords:** Only BCrypt hashes in `bank_users.passwordHash`; never store plain passwords.
- **Uniqueness:** Unique indexes on `username`, `email`, `accountNumber` prevent duplicates and mix-ups.
- **Application:** JWT and role-based access (customer vs admin) are already in the app.
- **Production:** Enable MongoDB authentication (user + password for DB), use TLS, restrict network access, and keep backups.
